using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using Application.Interfaces.WebsocketInterfaces;

namespace Infrastructure.Websocket;


public class ConnectionManager : IConnectionManager
{
    private readonly ILogger<ConnectionManager> _logger;

    // Maps Client ID > Socket
    private readonly ConcurrentDictionary<string, System.Net.WebSockets.WebSocket> _clientIdToSocket = new();
    // Maps Socket > Client ID
    private readonly ConcurrentDictionary<System.Net.WebSockets.WebSocket, string> _socketToClientId = new();
    // Maps Rooms > Client ID
    private readonly ConcurrentDictionary<string, HashSet<string>> _roomsToClientId = new();
    // Maps Client ID > Rooms
    private readonly ConcurrentDictionary<string, HashSet<string>> _clientIdToRooms = new();
    private readonly ConcurrentDictionary<string, string> _clientIdToUserId = new();
    private readonly ConcurrentDictionary<string, string> _clientIdToUsername = new();
    private readonly ConcurrentDictionary<string, HashSet<string>> _userIdToClientIds = new();
    
    public ConnectionManager(ILogger<ConnectionManager> logger)
    {
        _logger = logger;
    }

    public ConcurrentDictionary<string, object> GetConnectionIdToSocketDictionary()
    {
        // Convert to the expected return type (using object to match interface)
        var result = new ConcurrentDictionary<string, object>();
        foreach (var pair in _clientIdToSocket)
        {
            result.TryAdd(pair.Key, pair.Value);
        }
        return result;
    }

    public ConcurrentDictionary<string, string> GetSocketIdToClientIdDictionary()
    {
        var result = new ConcurrentDictionary<string, string>();
        foreach (var pair in _socketToClientId)
        {
            // Using the socket's hash code as an identifier since WebSockets don't have IDs
            result.TryAdd(pair.Key.GetHashCode().ToString(), pair.Value);
        }
        return result;
    }

    /// <param name="socket">The WebSocket connection object</param>
    /// <param name="clientId">Unique identifier for the client (usually generated by WebSocketHandler)</param>
    public Task OnOpen(object socket, string clientId, string userId = "", string username = "")
    {
        if (socket is System.Net.WebSockets.WebSocket webSocket)
        {
            _clientIdToSocket.TryAdd(clientId, webSocket);
            _socketToClientId.TryAdd(webSocket, clientId);

            if (!string.IsNullOrEmpty(userId))
            {
                _clientIdToUserId[clientId] = userId;

                // Track all connections for this user
                _userIdToClientIds.AddOrUpdate(
                    userId,
                    _ => new HashSet<string> { clientId },
                    (_, clientIds) => {
                        clientIds.Add(clientId);
                        return clientIds;
                    });
            }

            if (!string.IsNullOrEmpty(username))
            {
                _clientIdToUsername[clientId] = username;
            }

            AddToRoom("lobby", clientId).GetAwaiter().GetResult();

            string displayName = !string.IsNullOrEmpty(username) ? username : clientId;
            _logger.LogInformation("Client {ClientId} connected (User: {UserId}, Username: {Username})", 
            clientId, userId, displayName);
        }
        else
        {
            _logger.LogWarning("Attempted to connect non-WebSocket object for client {ClientId}", clientId);
        }
        
        return Task.CompletedTask;
    }

    /// <param name="socket">The WebSocket that was closed</param>
    /// <param name="clientId">Client ID (can be empty if unknown)</param>
    public Task OnClose(object socket, string clientId)
    {
        // If clientId wasn't provided, try to find it from the socket
        if (string.IsNullOrEmpty(clientId) && socket is System.Net.WebSockets.WebSocket webSocket)
        {
            // Using TryGetValue with out parameter - safer approach
            _socketToClientId.TryGetValue(webSocket, out string? clientIdFromSocket);
            clientId = clientIdFromSocket ?? string.Empty;
        }

        if (!string.IsNullOrEmpty(clientId))
        {
            // get user info for logging before removal
            _clientIdToUserId.TryGetValue(clientId, out string? userId);
            _clientIdToUsername.TryGetValue(clientId, out string? username);


            // Remove from client-to-socket mapping
            _clientIdToSocket.TryRemove(clientId, out _);
            
            // remove from user mappings
            _clientIdToUserId.TryRemove(clientId, out _);
            _clientIdToUsername.TryRemove(clientId, out _);

            // Update user-to-client mapping
            if (!string.IsNullOrEmpty(userId) && _userIdToClientIds.TryGetValue(userId, out var clientIds))
            {
                clientIds.Remove(clientId);
                if (clientIds.Count == 0)
                {
                    _userIdToClientIds.TryRemove(userId, out _);
                }
            }
            
            // Remove client from all rooms
            if (_clientIdToRooms.TryGetValue(clientId, out var rooms))
            {
                foreach (var room in rooms)
                {
                    // Call RemoveFromRoom for each room this client was in
                    RemoveFromRoom(room, clientId).GetAwaiter().GetResult();
                }
                _clientIdToRooms.TryRemove(clientId, out _);
            }

            string displayName = !string.IsNullOrEmpty(username) ? username : clientId;
            _logger.LogInformation("Client {ClientId} disconnected (User: {UserId}, Username: {Username})", 
            clientId, userId ?? string.Empty, displayName);
        }

        if (socket is System.Net.WebSockets.WebSocket webSocketObj)
        {
            _socketToClientId.TryRemove(webSocketObj, out _);
        }

        return Task.CompletedTask;
    }

    /// <param name="room">Name of the room (e.g., "game-123")</param>
    /// <param name="clientId">Client ID to add to the topic</param>
    public Task AddToRoom(string room, string clientId)
    {
        if (string.IsNullOrEmpty(room) || string.IsNullOrEmpty(clientId))
        {
            return Task.CompletedTask;
        }

        // Add client to room
        _roomsToClientId.AddOrUpdate(
            room,
            _ => new HashSet<string> { clientId }, // If room doesn't exist, create it with this client
            (_, clients) => // If topic exists, add member to the set
            {
                clients.Add(clientId);
                return clients;
            });
        
        // Add room to client's list
        _clientIdToRooms.AddOrUpdate(
            clientId,
            _ => new HashSet<string> { room },
            (_, rooms) =>
            {
                rooms.Add(room);
                return rooms;
            });

        _logger.LogInformation("Client {ClientId} added to room {Room}", clientId, room);
        return Task.CompletedTask;
    }
    
    public async Task SendToClient(string clientId, string message)
    {
        if (string.IsNullOrEmpty(clientId) || !_clientIdToSocket.TryGetValue(clientId, out var webSocket))
        {
            _logger.LogWarning("Attempted to send message to unknown client {ClientId}", clientId);
            return;
        }

        if (webSocket.State == System.Net.WebSockets.WebSocketState.Open)
        {
            try
            {
                var buffer = System.Text.Encoding.UTF8.GetBytes(message);
                await webSocket.SendAsync(
                    new ArraySegment<byte>(buffer, 0, buffer.Length),
                    System.Net.WebSockets.WebSocketMessageType.Text,
                    true,
                    CancellationToken.None
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending message to client {ClientId}", clientId);
            }
        }
    }

    public Task RemoveFromRoom(string room, string clientId)
    {
        if (string.IsNullOrEmpty(room) || string.IsNullOrEmpty(clientId))
        {
            return Task.CompletedTask;
        }

        // Remove client from room
        if (_roomsToClientId.TryGetValue(room, out var clients))
        {
            clients.Remove(clientId);
            
            // Remove room if empty
            if (clients.Count == 0)
            {
                _roomsToClientId.TryRemove(room, out _);
            }
        }
        
        // Remove room from client's list
        if (_clientIdToRooms.TryGetValue(clientId, out var rooms))
        {
            rooms.Remove(room);
            
            // Remove client if no room
            if (rooms.Count == 0)
            {
                _clientIdToRooms.TryRemove(clientId, out _);
            }
        }

        _logger.LogInformation("Client {ClientId} removed from room {Room}", clientId, room);
        return Task.CompletedTask;
    }


    /// <typeparam name="TMessage">Type of message (string or serializable object)</typeparam>
    /// <param name="room">The room to broadcast to</param>
    /// <param name="message">The message to send</param>
    /// TMessage allows messages: 
    /// BroadcastToRoom("game1", "Hello everyone");
    /// DTO objects: BroadcastToRoom("game1", new ChatMessageDto { Message = "Hello" });
    /// Custom classes: BroadcastToRoom("game1", new DrawingUpdate { x = 100, y = 150 });
    public Task BroadcastToRoom<TMessage>(string room, TMessage message) where TMessage : class
    {
        if (string.IsNullOrEmpty(room))
        {
            _logger.LogWarning("Attempted to broadcast to empty room");
            return Task.CompletedTask;
        }

        var clients = GetClientsFromRoomId(room).GetAwaiter().GetResult();
        // Convert message to string if it's not already
        var messageString = message as string ?? System.Text.Json.JsonSerializer.Serialize(message);
        // Send to each member in the topic
        foreach (var clientId in clients)
        {
            var webSocket = GetSocketFromClientId(clientId) as System.Net.WebSockets.WebSocket;
            if (webSocket != null && webSocket.State == System.Net.WebSockets.WebSocketState.Open)
            {
                try
                {
                    // 1. Convert string message to a byte array that can be sent over the network
                    // UTF-8 encoding handles international characters, emojis, etc.
                    var buffer = System.Text.Encoding.UTF8.GetBytes(messageString);
                    
                    // 2. Send the byte array via WebSocket using SendAsync method
                    webSocket.SendAsync(
                        // ArraySegment is a memory-efficient way to reference a portion of an array
                        // without creating a copy. It's like saying "use this section of the buffer"
                        // Parameters: 
                        //   - buffer: the source byte array 
                        //   - 0: start from the beginning of the array (index 0)
                        //   - buffer.Length: use the entire length of the array
                        new ArraySegment<byte>(buffer, 0, buffer.Length),
                        
                        // 3. Specify this is a text message (not binary data or control frame)
                        // This tells the receiver (browser/client) how to interpret the bytes
                        System.Net.WebSockets.WebSocketMessageType.Text,
                        
                        // 4. true = "endOfMessage" - indicates this is a complete message
                        // WebSockets can fragment large messages across multiple frames
                        // Setting this to true means "this is the final fragment"
                        true,
                        
                        // 5. CancellationToken.None means we won't cancel this operation
                        // In a more advanced implementation, you might pass a token
                        // that could cancel long-running send operations
                        CancellationToken.None
                    )
                    // 6. Wait synchronously for the async operation to complete
                    // This ensures the message is sent before we move to the next client
                    // Without this, the method might return before messages are actually sent
                    .GetAwaiter().GetResult();
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error broadcasting to client {ClientId}", clientId);
                }
            }
        }
        
        return Task.CompletedTask;
    }

    public Task<List<string>> GetClientsFromRoomId(string room)
    {
        if (string.IsNullOrEmpty(room) || !_roomsToClientId.TryGetValue(room, out var clients))
        {
            return Task.FromResult(new List<string>());
        }
        
        return Task.FromResult(clients.ToList());
    }

    // Probably wont use this method, but keeping it for completeness
    // This gives a list of all rooms a client is in
    public Task<List<string>> GetRoomsFromClientId(string clientId)
    {
        if (string.IsNullOrEmpty(clientId) || !_clientIdToRooms.TryGetValue(clientId, out var rooms))
        {
            return Task.FromResult(new List<string>());
        }
        
        return Task.FromResult(rooms.ToList());
    }


    // Gets the clientId from the socket object
    public string GetClientIdFromSocket(object socket)
    {
        if (socket is System.Net.WebSockets.WebSocket webSocket && _socketToClientId.TryGetValue(webSocket, out var clientId))
        {
            return clientId;
        }
        
        return string.Empty;
    }

    public Task<List<string>> GetClientIdsForUser(string userId)
    {
        if (string.IsNullOrEmpty(userId) || !_userIdToClientIds.TryGetValue(userId, out var clientIds))
        {
            return Task.FromResult(new List<string>());
        }

        return Task.FromResult(clientIds.ToList());
    }

    public bool IsUserConnected(string userId)
    {
        return !string.IsNullOrEmpty(userId) && 
               _userIdToClientIds.TryGetValue(userId, out var clientIds) && 
               clientIds.Count > 0;
    }


    /// <summary>
    /// Gets the WebSocket connection object for a specific client ID.
    /// </summary>
    /// <param name="clientId">Client ID to look up</param>
    /// <returns>WebSocket object or null if not found</returns>
    public object? GetSocketFromClientId(string clientId)
    {
        if (!string.IsNullOrEmpty(clientId) && _clientIdToSocket.TryGetValue(clientId, out var socket))
        {
            return socket;
        }
        
        return null;
    }

    public Task<string> GetUserIdFromClientId(string clientId)
    {
        if (!string.IsNullOrEmpty(clientId) && _clientIdToUserId.TryGetValue(clientId, out var userId))
        {
            return Task.FromResult(userId);
        }

        return Task.FromResult(string.Empty);
    }

    
}