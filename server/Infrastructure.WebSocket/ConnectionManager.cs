using System.Collections.Concurrent;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using Application.Interfaces.WebsocketInterfaces;

namespace Infrastructure.Websocket;


public class ConnectionManager : IConnectionManager
{
    private readonly ILogger<ConnectionManager> _logger;

    // Maps Client ID > Socket
    private readonly ConcurrentDictionary<string, System.Net.WebSockets.WebSocket> _clientIdToSocket = new();
    // Maps Socket > Client ID
    private readonly ConcurrentDictionary<System.Net.WebSockets.WebSocket, string> _socketToClientId = new();
    // Maps Rooms > Client ID
    private readonly ConcurrentDictionary<string, HashSet<string>> _roomsToClientId = new();
    // Maps Client ID > Rooms
    private readonly ConcurrentDictionary<string, HashSet<string>> _clientIdToRooms = new();
    private readonly ConcurrentDictionary<string, string> _clientIdToUserId = new();
    private readonly ConcurrentDictionary<string, string> _clientIdToUsername = new();
    private readonly ConcurrentDictionary<string, HashSet<string>> _userIdToClientIds = new();
    
    public ConnectionManager(ILogger<ConnectionManager> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Returns a dictionary of all active client connections.
    /// This method is primarily for diagnostic, debugging, and monitoring purposes.
    /// </summary>
    /// <returns>Dictionary mapping client IDs to WebSocket objects</returns>
    private ConcurrentDictionary<string, object> GetConnectionIdToSocketDictionary()
    {
        // Convert to the expected return type (using object to match interface)
        var result = new ConcurrentDictionary<string, object>();
        foreach (var pair in _clientIdToSocket)
        {
            result.TryAdd(pair.Key, pair.Value);
        }
        return result;
    }
    
    /// <summary>
    /// Returns a dictionary mapping socket identifiers to client IDs.
    /// Since System.Net.WebSockets.WebSocket doesn't have built-in IDs, 
    /// we use the object's hash code as an identifier.
    /// This is not ideal but fine for simple logging which is all that this is being used for.
    /// </summary>
    /// <returns>Dictionary mapping WebSocket hash codes to client IDs</returns>
    private ConcurrentDictionary<string, string> GetSocketIdToClientIdDictionary()
    {
        var result = new ConcurrentDictionary<string, string>();
        foreach (var pair in _socketToClientId)
        {
            // Using the socket's hash code as an identifier since WebSockets don't have IDs
            result.TryAdd(pair.Key.GetHashCode().ToString(), pair.Value);
        }
        return result;
    }

    /// <param name="socket">The WebSocket connection object</param>
    /// <param name="clientId">Unique identifier for the client (usually generated by WebSocketHandler)</param>
    /// <param name="userId">User ID (optional)</param>
    /// <param name="username">Username (optional)</param>
    public async Task OnOpen(object socket, string clientId, string userId = "", string username = "")
    {
        if (socket is System.Net.WebSockets.WebSocket webSocket)
        {
            _clientIdToSocket.TryAdd(clientId, webSocket);
            _socketToClientId.TryAdd(webSocket, clientId);

            if (!string.IsNullOrEmpty(userId))
            {
                _clientIdToUserId[clientId] = userId;

                // Track all connections for this user
                _userIdToClientIds.AddOrUpdate(
                    userId,
                    _ => new HashSet<string> { clientId },
                    (_, clientIds) => {
                        clientIds.Add(clientId);
                        return clientIds;
                    });
            }

            if (!string.IsNullOrEmpty(username))
            {
                _clientIdToUsername[clientId] = username;
            }

            await AddToRoom("lobby", clientId);

            string displayName = !string.IsNullOrEmpty(username) ? username : clientId;
            _logger.LogInformation("Client {ClientId} connected (User: {UserId}, Username: {Username})", 
            clientId, userId, displayName);
        }
        else
        {
            _logger.LogWarning("Attempted to connect non-WebSocket object for client {ClientId}", clientId);
        }
        await LogCurrentState();
    }

    /// <param name="socket">The WebSocket that was closed</param>
    /// <param name="clientId">Client ID (can be empty if unknown)</param>
    public async Task OnClose(object socket, string clientId)
    {
        // If clientId wasn't provided, try to find it from the socket
        if (string.IsNullOrEmpty(clientId) && socket is System.Net.WebSockets.WebSocket webSocket)
        {
            // Using TryGetValue with out parameter - safer approach
            _socketToClientId.TryGetValue(webSocket, out string? clientIdFromSocket);
            clientId = clientIdFromSocket ?? string.Empty;
        }

        if (!string.IsNullOrEmpty(clientId))
        {
            // get user info for logging before removal
            _clientIdToUserId.TryGetValue(clientId, out string? userId);
            _clientIdToUsername.TryGetValue(clientId, out string? username);


            // Remove from client-to-socket mapping
            _clientIdToSocket.TryRemove(clientId, out _);
            
            // remove from user mappings
            _clientIdToUserId.TryRemove(clientId, out _);
            _clientIdToUsername.TryRemove(clientId, out _);

            // Update user-to-client mapping
            if (!string.IsNullOrEmpty(userId) && _userIdToClientIds.TryGetValue(userId, out var clientIds))
            {
                clientIds.Remove(clientId);
                if (clientIds.Count == 0)
                {
                    _userIdToClientIds.TryRemove(userId, out _);
                }
            }
            
            // Remove client from all rooms
            if (_clientIdToRooms.TryGetValue(clientId, out var rooms))
            {
                foreach (var room in rooms)
                {
                    // Call RemoveFromRoom for each room this client was in
                    await RemoveFromRoom(room, clientId);
                }
                _clientIdToRooms.TryRemove(clientId, out _);
            }

            string displayName = !string.IsNullOrEmpty(username) ? username : clientId;
            _logger.LogInformation("Client {ClientId} disconnected (User: {UserId}, Username: {Username})", 
            clientId, userId ?? string.Empty, displayName);
        }

        if (socket is System.Net.WebSockets.WebSocket webSocketObj)
        {
            _socketToClientId.TryRemove(webSocketObj, out _);
        }
        await LogCurrentState();
    }

    /// <param name="room">Name of the room (e.g., "game-123")</param>
    /// <param name="clientId">Client ID to add to the topic</param>
    public Task AddToRoom(string room, string clientId)
    {
        if (string.IsNullOrEmpty(room) || string.IsNullOrEmpty(clientId))
        {
            return Task.CompletedTask;
        }

        // Add client to room
        _roomsToClientId.AddOrUpdate(
            room,
            _ => new HashSet<string> { clientId }, // If room doesn't exist, create it with this client
            (_, clients) => // If topic exists, add member to the set
            {
                clients.Add(clientId);
                return clients;
            });
        
        // Add room to client's list
        _clientIdToRooms.AddOrUpdate(
            clientId,
            _ => new HashSet<string> { room },
            (_, rooms) =>
            {
                rooms.Add(room);
                return rooms;
            });

        _logger.LogInformation("Client {ClientId} added to room {Room}", clientId, room);
        LogCurrentState();
        return Task.CompletedTask;
    }
    


    public Task RemoveFromRoom(string room, string clientId)
    {
        if (string.IsNullOrEmpty(room) || string.IsNullOrEmpty(clientId))
        {
            return Task.CompletedTask;
        }
        
        // Remove client from room
        if (_roomsToClientId.TryGetValue(room, out var clients))
        {
            clients.Remove(clientId);
            
            // Remove room if empty
            if (clients.Count == 0)
            {
                _roomsToClientId.TryRemove(room, out _);
            }
        }
        
        // Remove room from client's list
        if (_clientIdToRooms.TryGetValue(clientId, out var rooms))
        {
            rooms.Remove(room);
            
            // Remove client if no room
            if (rooms.Count == 0)
            {
                _clientIdToRooms.TryRemove(clientId, out _);
            }
        }

        _logger.LogInformation("Client {ClientId} removed from room {Room}", clientId, room);
        LogCurrentState();  
        return Task.CompletedTask;
    }
    
    public Task<List<string>> GetClientsFromRoomId(string room)
    {
        if (string.IsNullOrEmpty(room) || !_roomsToClientId.TryGetValue(room, out var clients))
        {
            return Task.FromResult(new List<string>());
        }
        
        return Task.FromResult(clients.ToList());
    }

    // Probably wont use this method, but keeping it for completeness
    // This gives a list of all rooms a client is in
    public Task<List<string>> GetRoomsFromClientId(string clientId)
    {
        if (string.IsNullOrEmpty(clientId) || !_clientIdToRooms.TryGetValue(clientId, out var rooms))
        {
            return Task.FromResult(new List<string>());
        }
        
        return Task.FromResult(rooms.ToList());
    }
    

    public Task<List<string>> GetClientIdsForUser(string userId)
    {
        if (string.IsNullOrEmpty(userId) || !_userIdToClientIds.TryGetValue(userId, out var clientIds))
        {
            return Task.FromResult(new List<string>());
        }

        return Task.FromResult(clientIds.ToList());
    }
    

    /// <summary>
    /// Gets the WebSocket connection object for a specific client ID.
    /// </summary>
    /// <param name="clientId">Client ID to look up</param>
    /// <returns>WebSocket object or null if not found</returns>
    public object? GetSocketFromClientId(string clientId)
    {
        if (!string.IsNullOrEmpty(clientId) && _clientIdToSocket.TryGetValue(clientId, out var socket))
        {
            return socket;
        }
        
        return null;
    }

    public Task<string> GetUserIdFromClientId(string clientId)
    {
        if (!string.IsNullOrEmpty(clientId) && _clientIdToUserId.TryGetValue(clientId, out var userId))
        {
            return Task.FromResult(userId);
        }

        return Task.FromResult(string.Empty);
    }

    /// <summary>
    /// Logs the current connection state for debugging and monitoring.
    /// </summary>
    private Task LogCurrentState()
    {
        try
        {
            var clientToSocket = GetConnectionIdToSocketDictionary();
            var socketToClient = GetSocketIdToClientIdDictionary();
            
            var state = new
            {
                Connections = clientToSocket.Keys,
                ConnectionCount = clientToSocket.Count,
                SocketMappings = socketToClient,
                Rooms = _roomsToClientId,
                ClientRooms = _clientIdToRooms
            };
    
            _logger.LogDebug("Current state: {State}",
                JsonSerializer.Serialize(state, new JsonSerializerOptions { WriteIndented = true }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error logging connection state");
        }
        
        return Task.CompletedTask;
    }
    
}